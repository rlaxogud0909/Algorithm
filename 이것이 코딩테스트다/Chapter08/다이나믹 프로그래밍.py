# 다이나믹 프로그랭
# 조건
# 1) 큰 문제를 작은 문제로 나눌 수 있따.
# 2) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

# 메모이제이션 기법: 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한
# 결과를 그대로 가져오는 기법
# 캐싱: 메모이제이션에서 값을 저장하는 방법

# 피보나치 함수 소스코드
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))


# f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어남
# 피보나치 함수 빅오표기법 -> O(2^N)
# ex) n = 30 일때 10억 가량 연산 수행

# # 피보나치 수열 소스코드(재귀적)
# 한 번 계산 된 결과를 메모이제이션 하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))



# 탑다운 (큰문제를 해결하기 위해 작은 문제를 호출)
# 호출되는 함수 확인
d = [0] * 100

def pibo(x):
    print('f(' + str(x) +')', end=' ')
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = pibo(x-1) + pibo(x-2)
    return d[x]

pibo(6)

# 보텀업: 반복문을 이용하여 소스코드를 작섷아는 경우 작은 무제부터 차근차근 답을 도출
# 탑다운보단 보텀업을 권장
# 피보나치 수열 소스코드(반복문)
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
    
print(d[n])